<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Robota API 문서</title>
  <meta name="description" content="Robota API 문서">
  <link rel="stylesheet" href="/style.css">
  <script>
    // 페이지 로드 시 Docsify 라우팅으로 리다이렉트
    window.onload = function() {
      // history 모드를 위한 리다이렉트 처리
      const currentPath = window.location.pathname;
      
      // HTML 확장자 제거하여 원래 경로로 리다이렉트
      if (currentPath.endsWith('.html')) {
        window.location.href = currentPath.replace('.html', '');
        return;
      }
      
      // 이미 적절한 경로라면 Docsify로 전달
      window.location.href = '/';
    };
  </script>
</head>
<body>
  <div id="content">
    <h1>코드 구조 및 개선사항</h1>
<p>Robota 라이브러리는 지속적인 개선을 통해 코드 품질과 개발자 경험을 향상시키고 있습니다. 이 문서에서는 최근 리팩토링 및 코드 개선 작업에 대한 상세 내용을 제공합니다.</p>
<h2>구조적 개선사항</h2>
<h3>모듈화 및 분리</h3>
<p>코드베이스는 다음과 같이 논리적으로 분리되어 있습니다:</p>
<pre><code>packages/
├── core/               # 핵심 기능
│   ├── robota.ts       # 메인 클래스 
│   ├── memory.ts       # 메모리 관리
│   ├── types.ts        # 타입 정의
│   └── ...
├── openai/             # OpenAI 통합
├── anthropic/          # Anthropic 통합
├── tools/              # 도구 시스템
└── ...
</code></pre>
<p>이러한 모듈화는 다음과 같은 이점을 제공합니다:</p>
<ol>
<li><strong>코드 재사용성</strong>: 공통 기능이 적절히 분리되어 중복 코드가 감소했습니다.</li>
<li><strong>유지보수성</strong>: 한 모듈의 변경이 다른 모듈에 미치는 영향이 최소화되었습니다.</li>
<li><strong>테스트 용이성</strong>: 독립적인 모듈은 단위 테스트가 용이합니다.</li>
<li><strong>번들 크기 최적화</strong>: 사용자는 필요한 모듈만 가져와서 번들 크기를 최적화할 수 있습니다.</li>
</ol>
<h3>인터페이스 개선</h3>
<p>핵심 인터페이스들이 다음과 같이 개선되었습니다:</p>
<ol>
<li><strong>ModelContextProtocol</strong>: AI 모델과의 통신을 위한 표준화된, 확장 가능한 인터페이스 제공</li>
<li><strong>Memory</strong>: 대화 기록 관리를 위한 명확한 계약 정의</li>
<li><strong>Tool</strong>: 도구 정의 및 실행을 위한 확장 가능한 인터페이스</li>
</ol>
<h2>타입 시스템 개선</h2>
<h3>제네릭 타입 도입</h3>
<pre><code class="language-typescript">// 이전:
interface Tool {
  name: string;
  description?: string;
  execute: (...args: any[]) =&gt; Promise&lt;any&gt;;
}

// 개선:
interface Tool&lt;TInput = any, TOutput = any&gt; {
  name: string;
  description?: string;
  parameters?: ToolParameter[];
  execute: (input: TInput) =&gt; Promise&lt;ToolResult&lt;TOutput&gt;&gt;;
}
</code></pre>
<h3>명시적 타입 검사 추가</h3>
<pre><code class="language-typescript">// 함수 매개변수 유효성 검사
registerFunction(schema: FunctionSchema, fn: Function): void {
  if (!schema || !schema.name) {
    throw new Error(&#39;유효한 함수 스키마가 필요합니다.&#39;);
  }
  if (typeof fn !== &#39;function&#39;) {
    throw new Error(&#39;두 번째 인자는 함수여야 합니다.&#39;);
  }
  
  // 구현...
}
</code></pre>
<h2>코드 가독성 개선</h2>
<h3>주석 및 문서화</h3>
<p>모든 주요 클래스, 메서드, 및 프로퍼티에 JSDoc 주석을 추가하였습니다:</p>
<pre><code class="language-typescript">/**
 * 특정 위치의 날씨 정보를 가져오는 도구
 * 
 * @example
 * ```ts
 * const weatherTool = createTool({
 *   name: &#39;getWeather&#39;,
 *   description: &#39;특정 위치의 날씨를 조회합니다&#39;,
 *   // ... 코드 생략
 * });
 * ```
 */
</code></pre>
<h3>일관된 메서드 그룹화</h3>
<p>관련 메서드를 논리적 그룹으로 분류하여 코드 구조를 명확하게 했습니다:</p>
<pre><code class="language-typescript">class Robota {
  // 시스템 메시지 관리
  setSystemPrompt() { /* ... */ }
  setSystemMessages() { /* ... */ }
  addSystemMessage() { /* ... */ }
  
  // 함수 호출 관리
  setFunctionCallMode() { /* ... */ }
  configureFunctionCall() { /* ... */ }
  registerFunction() { /* ... */ }
  
  // 실행 메서드
  run() { /* ... */ }
  chat() { /* ... */ }
  
  // 내부 헬퍼 메서드
  private prepareContext() { /* ... */ }
  private handleFunctionCall() { /* ... */ }
}
</code></pre>
<h2>에러 처리 개선</h2>
<p>에러 처리가 다양한 상황에서 더 구체적이고 유용한 피드백을 제공하도록 개선되었습니다:</p>
<pre><code class="language-typescript">async handleFunctionCall(response, context, options): Promise&lt;string&gt; {
  if (!response.functionCall || !response.functionCall.name) {
    throw new Error(&#39;함수 호출 정보가 누락되었습니다.&#39;);
  }

  const functionName = response.functionCall.name;
  const fn = this.functions[functionName];

  if (!fn) {
    throw new Error(`함수 &#39;${functionName}&#39;이(가) 등록되지 않았습니다.`);
  }
  
  try {
    // 함수 실행...
  } catch (error) {
    console.error(`함수 &#39;${functionName}&#39; 실행 중 오류 발생:`, error);
    throw error;
  }
}
</code></pre>
<h2>테스트 개선</h2>
<h3>테스트 위치 및 구조</h3>
<p>테스트 파일은 해당 구현 파일과 함께 배치하여 관리가 용이하도록 하였습니다:</p>
<pre><code>packages/core/src/
  ├── memory.ts
  ├── memory.test.ts  // memory.ts에 대한 테스트
  ├── robota.ts
  └── robota.test.ts  // robota.ts에 대한 테스트
</code></pre>
<h3>테스트 범위 확대</h3>
<p>다음 영역에서 테스트 커버리지가 향상되었습니다:</p>
<ol>
<li><strong>에지 케이스</strong>: 비정상적인 입력과 경계 조건에 대한 테스트</li>
<li><strong>오류 상황</strong>: 예외 발생 시 올바르게 처리되는지 확인</li>
<li><strong>통합 테스트</strong>: 여러 컴포넌트가 함께 작동하는 시나리오 테스트</li>
</ol>
<h2>API 디자인 개선</h2>
<h3>일관된 명명 규칙</h3>
<p>모든 API는 일관된 명명 규칙을 따릅니다:</p>
<ul>
<li>클래스: PascalCase (예: <code>OpenAIProvider</code>)</li>
<li>메서드: camelCase (예: <code>registerFunction</code>, <code>setSystemPrompt</code>)</li>
<li>상수: UPPER_SNAKE_CASE (예: <code>DEFAULT_TIMEOUT</code>, <code>MAX_TOKENS</code>)</li>
<li>타입/인터페이스: PascalCase (예: <code>ToolResult</code>, <code>FunctionSchema</code>)</li>
</ul>
<h3>메서드 체이닝 지원</h3>
<pre><code class="language-typescript">// 이전:
toolRegistry.register(tool1);
toolRegistry.register(tool2);

// 개선:
toolRegistry
  .register(tool1)
  .register(tool2);
</code></pre>
<h2>성능 개선</h2>
<h3>메모리 최적화</h3>
<p>메모리 관리 시스템이 개선되어 대화 기록을 효율적으로 저장하고 검색할 수 있습니다:</p>
<pre><code class="language-typescript">class SimpleMemory implements Memory {
  private messages: Message[] = [];
  private maxMessages: number;
  
  constructor(options?: { maxMessages?: number }) {
    this.maxMessages = options?.maxMessages || 0;
  }
  
  addMessage(message: Message): void {
    this.messages.push(message);
    
    // 최대 메시지 수 제한 적용
    if (this.maxMessages &gt; 0 &amp;&amp; this.messages.length &gt; this.maxMessages) {
      // 시스템 메시지는 항상 유지
      const systemMessages = this.messages.filter(m =&gt; m.role === &#39;system&#39;);
      const nonSystemMessages = this.messages.filter(m =&gt; m.role !== &#39;system&#39;);
      
      // 비시스템 메시지만 잘라냄
      const remainingCount = this.maxMessages - systemMessages.length;
      const trimmedNonSystemMessages = nonSystemMessages.slice(-remainingCount);
      
      // 시스템 메시지와 잘라낸 비시스템 메시지 합치기
      this.messages = [...systemMessages, ...trimmedNonSystemMessages];
    }
  }
}
</code></pre>
<h2>결론</h2>
<p>이러한 코드 개선을 통해 Robota 라이브러리는 다음과 같은 이점을 제공합니다:</p>
<ol>
<li><strong>더 나은 개발자 경험</strong>: 직관적인 API와 명확한 문서화</li>
<li><strong>향상된 타입 안전성</strong>: 컴파일 타임에 오류 발견</li>
<li><strong>더 높은 코드 품질</strong>: 일관된 스타일과 설계 원칙</li>
<li><strong>확장성</strong>: 새로운 기능과 통합을 쉽게 추가할 수 있음</li>
<li><strong>유지보수성</strong>: 명확한 모듈 경계와 책임 분리</li>
</ol>
<p>향후 개발 계획에는 추가 최적화, 더 많은 제공업체 지원, 그리고 고급 기능의 구현이 포함되어 있습니다. </p>

  </div>
</body>
</html>