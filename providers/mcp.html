<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Robota API 문서</title>
  <meta name="description" content="Robota API 문서">
  <link rel="stylesheet" href="/robota/style.css">
</head>
<body>
  <div id="content">
    <h1>MCP 제공업체 (Model Context Protocol)</h1>
<p>MCP(Model Context Protocol) 제공업체는 Model Context Protocol을 지원하는 다양한 AI 모델과 통합할 수 있도록 해줍니다. MCP는 AI 모델과의 상호작용을 위한 표준화된 프로토콜입니다.</p>
<h2>특징</h2>
<ul>
<li>Model Context Protocol을 지원하는 모든 모델과 호환</li>
<li>두 가지 통합 방식 지원: 직접 MCP 클라이언트 주입 또는 OpenAPI 스키마 기반 통합</li>
<li>함수 호출(Function Calling) 지원</li>
<li>스트리밍 응답 지원</li>
</ul>
<h2>설치</h2>
<pre><code class="language-bash">npm install @robota/mcp
</code></pre>
<h2>사용법</h2>
<h3>클라이언트 주입 방식</h3>
<p><code>@modelcontextprotocol/sdk</code> 라이브러리를 사용하여 MCP 클라이언트를 생성하고 이를 제공업체에 주입하는 방식입니다.</p>
<pre><code class="language-typescript">import { Robota, MCPProvider } from &#39;robota&#39;;
import { Client, StdioClientTransport } from &#39;@modelcontextprotocol/sdk&#39;;

// MCP 클라이언트 생성
const transport = new StdioClientTransport(/* 설정 */);
const mcpClient = new Client(transport);

// MCP 제공업체 초기화
const provider = new MCPProvider({
  type: &#39;client&#39;,
  client: mcpClient,
  model: &#39;model-name&#39;, // 사용할 모델 이름
  temperature: 0.7
});

// Robota 인스턴스에 제공업체 연결
const robota = new Robota({ provider });

// 실행
const result = await robota.run(&#39;안녕하세요! 오늘 날씨가 어때요?&#39;);
</code></pre>
<h3>OpenAPI 스키마 방식</h3>
<p>OpenAPI 3.0 스키마를 사용하여 MCP API와 통합하는 방식입니다.</p>
<pre><code class="language-typescript">import { Robota, MCPProvider } from &#39;robota&#39;;

// OpenAPI 스키마 방식으로 MCP 제공업체 초기화
const provider = new MCPProvider({
  type: &#39;openapi&#39;,
  schema: &#39;https://example.com/mcp-api/openapi.json&#39;, // 또는 스키마 객체
  baseURL: &#39;https://api.example.com/v1&#39;,
  headers: {
    &#39;Authorization&#39;: `Bearer ${process.env.MCP_API_KEY}`
  },
  model: &#39;model-name&#39;, // 사용할 모델 이름
  temperature: 0.7
});

// Robota 인스턴스에 제공업체 연결
const robota = new Robota({ provider });

// 실행
const result = await robota.run(&#39;안녕하세요! 함수 호출 테스트입니다.&#39;);
</code></pre>
<h2>함수 호출 예제</h2>
<p>MCP 제공업체에서 함수 호출을 사용하는 예제입니다.</p>
<pre><code class="language-typescript">import { Robota, MCPProvider } from &#39;robota&#39;;
import { Client, StdioClientTransport } from &#39;@modelcontextprotocol/sdk&#39;;

// MCP 클라이언트 생성
const transport = new StdioClientTransport(/* 설정 */);
const mcpClient = new Client(transport);

// MCP 제공업체 초기화
const provider = new MCPProvider({
  type: &#39;client&#39;,
  client: mcpClient,
  model: &#39;model-name&#39;
});

// Robota 인스턴스 생성
const robota = new Robota({ provider });

// 함수 등록
robota.registerFunctions({
  getWeather: async (location: string) =&gt; {
    // 날씨 정보 조회 로직
    return { temperature: 22, condition: &#39;맑음&#39;, location };
  }
});

// 실행
const result = await robota.run(&#39;서울의 날씨가 어때요?&#39;);
console.log(result); // AI가 getWeather 함수를 호출하고 결과를 응답에 포함합니다.
</code></pre>
<h2>고급 설정</h2>
<h3>스트리밍 응답 사용</h3>
<pre><code class="language-typescript">import { Robota, MCPProvider } from &#39;robota&#39;;
import { Client, StdioClientTransport } from &#39;@modelcontextprotocol/sdk&#39;;

// MCP 클라이언트 생성
const transport = new StdioClientTransport(/* 설정 */);
const mcpClient = new Client(transport);

// MCP 제공업체 초기화
const provider = new MCPProvider({
  type: &#39;client&#39;,
  client: mcpClient,
  model: &#39;model-name&#39;
});

// Robota 인스턴스 생성
const robota = new Robota({ provider });

// 스트리밍 응답 처리
const stream = await robota.stream(&#39;긴 이야기를 해주세요.&#39;);

for await (const chunk of stream) {
  process.stdout.write(chunk.content || &#39;&#39;);
}
</code></pre>
<h2>주의사항</h2>
<ul>
<li>MCP 제공업체를 사용할 때는 반드시 MCP 클라이언트 또는 OpenAPI 스키마를 제공해야 합니다.</li>
<li>클라이언트 타입(<code>type</code> 옵션)은 &#39;client&#39; 또는 &#39;openapi&#39; 중 하나여야 합니다.</li>
<li>사용하는 MCP 구현체에 따라 지원되는 기능이 다를 수 있습니다.</li>
</ul>

  </div>
  <script>
    // 페이지가 로드되면 Docsify로 리다이렉션
    window.addEventListener('DOMContentLoaded', function() {
      // 현재 경로에서 .html 확장자 제거
      const currentPath = window.location.pathname;
      if (currentPath.endsWith('.html')) {
        // history 모드를 위한 리다이렉션
        const newPath = currentPath.replace('.html', '');
        window.location.replace(newPath);
      }
    });
  </script>
</body>
</html>