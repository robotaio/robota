<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Robota API 문서</title>
  <meta name="description" content="Robota API 문서">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <div id="content">
    <h1>모델 컨텍스트 프로토콜 (Model Context Protocol)</h1>
<p>모델 컨텍스트 프로토콜(MCP)은 다양한 AI 모델과 일관된 방식으로 통신하기 위한 Robota의 표준화된 방법입니다. 이 프로토콜을 통해 서로 다른 AI 제공업체 간의 호환성을 보장하고, 모델 간 전환을 쉽게 할 수 있습니다.</p>
<h2>프로토콜 개요</h2>
<p>MCP는 다음 요소로 구성됩니다:</p>
<ol>
<li><strong>메시지 형식</strong> - 사용자와 AI 간의 대화를 구조화하는 방법</li>
<li><strong>함수 스키마</strong> - 함수와 도구의 정의를 표현하는 방법</li>
<li><strong>컨텍스트 관리</strong> - 대화 컨텍스트와 상태를 관리하는 방법</li>
<li><strong>응답 형식</strong> - AI의 응답을 구조화하는 방법</li>
</ol>
<h2>메시지 형식</h2>
<p>MCP에서 메시지는 다음과 같은 구조를 가집니다:</p>
<pre><code class="language-typescript">interface Message {
  role: &#39;user&#39; | &#39;assistant&#39; | &#39;system&#39; | &#39;function&#39;;
  content: string;
  name?: string;  // function 호출인 경우 함수 이름
  functionCall?: {
    name: string;
    arguments: Record&lt;string, any&gt;;
  };
  functionResult?: any;
}
</code></pre>
<p>예시:</p>
<pre><code class="language-typescript">// 사용자 메시지
const userMessage: Message = {
  role: &#39;user&#39;,
  content: &#39;서울의 날씨가 어때?&#39;
};

// 시스템 메시지
const systemMessage: Message = {
  role: &#39;system&#39;,
  content: &#39;당신은 도움이 되는 AI 비서입니다.&#39;
};

// 함수 호출을 포함한 어시스턴트 메시지
const assistantMessage: Message = {
  role: &#39;assistant&#39;,
  content: &#39;서울의 날씨를 확인해보겠습니다.&#39;,
  functionCall: {
    name: &#39;getWeather&#39;,
    arguments: { location: &#39;서울&#39; }
  }
};

// 함수 결과 메시지
const functionMessage: Message = {
  role: &#39;function&#39;,
  name: &#39;getWeather&#39;,
  content: JSON.stringify({ temperature: 25, condition: &#39;맑음&#39; })
};
</code></pre>
<h2>함수 스키마</h2>
<p>MCP는 함수를 JSON 스키마 형식으로 정의합니다:</p>
<pre><code class="language-typescript">interface FunctionSchema {
  name: string;
  description?: string;
  parameters: {
    type: &#39;object&#39;;
    properties: Record&lt;string, {
      type: string;
      description?: string;
      enum?: any[];
      default?: any;
      // 추가 JSON 스키마 속성
    }&gt;;
    required?: string[];
  };
}
</code></pre>
<p>예시:</p>
<pre><code class="language-typescript">const weatherFunctionSchema: FunctionSchema = {
  name: &#39;getWeather&#39;,
  description: &#39;특정 위치의 현재 날씨 정보를 가져옵니다&#39;,
  parameters: {
    type: &#39;object&#39;,
    properties: {
      location: {
        type: &#39;string&#39;,
        description: &#39;날씨를 확인할 도시 이름 (예: 서울, 부산)&#39;
      },
      unit: {
        type: &#39;string&#39;,
        description: &#39;온도 단위&#39;,
        enum: [&#39;celsius&#39;, &#39;fahrenheit&#39;],
        default: &#39;celsius&#39;
      }
    },
    required: [&#39;location&#39;]
  }
};
</code></pre>
<h2>컨텍스트 관리</h2>
<p>MCP에서 컨텍스트는 대화의 상태를 나타내며, 다음 요소를 포함합니다:</p>
<pre><code class="language-typescript">interface Context {
  messages: Message[];            // 지금까지의 대화 기록
  functions?: FunctionSchema[];   // 사용 가능한 함수 목록
  systemPrompt?: string;          // 단일 시스템 프롬프트
  systemMessages?: Message[];     // 여러 시스템 메시지
  metadata?: Record&lt;string, any&gt;; // 추가 메타데이터
}
</code></pre>
<h3>시스템 메시지 관리</h3>
<p>Robota는 단일 시스템 프롬프트와 여러 시스템 메시지를 모두 지원합니다:</p>
<pre><code class="language-typescript">// 단일 시스템 프롬프트 설정
robota.setSystemPrompt(&#39;당신은 도움이 되는 AI 어시스턴트입니다.&#39;);

// 여러 시스템 메시지 설정
robota.setSystemMessages([
  { role: &#39;system&#39;, content: &#39;당신은 전문 데이터 분석가입니다.&#39; },
  { role: &#39;system&#39;, content: &#39;사용자가 데이터 분석 관련 질문을 할 때마다 단계별로 설명해주세요.&#39; }
]);

// 기존 시스템 메시지에 추가
robota.addSystemMessage(&#39;항상 정확한 정보를 제공하려고 노력하세요.&#39;);
</code></pre>
<p>Robota 인스턴스 생성 시 시스템 메시지를 설정할 수도 있습니다:</p>
<pre><code class="language-typescript">// 단일 시스템 프롬프트로 초기화
const robota1 = new Robota({
  provider: provider,
  systemPrompt: &#39;당신은 도움이 되는 AI 어시스턴트입니다.&#39;
});

// 여러 시스템 메시지로 초기화
const robota2 = new Robota({
  provider: provider,
  systemMessages: [
    { role: &#39;system&#39;, content: &#39;당신은 전문 데이터 분석가입니다.&#39; },
    { role: &#39;system&#39;, content: &#39;사용자가 데이터 분석 관련 질문을 할 때마다 단계별로 설명해주세요.&#39; }
  ]
});
</code></pre>
<h2>응답 형식</h2>
<p>모델의 응답은 다음과 같은 구조로 표준화됩니다:</p>
<pre><code class="language-typescript">interface ModelResponse {
  content?: string;               // 텍스트 응답
  functionCall?: {                // 함수 호출 (있는 경우)
    name: string;
    arguments: Record&lt;string, any&gt;;
  };
  usage?: {                       // 토큰 사용량 정보
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  metadata?: Record&lt;string, any&gt;; // 추가 메타데이터
}
</code></pre>
<h2>제공업체 간 프로토콜 변환</h2>
<p>Robota는 각 AI 제공업체의 고유한 API 형식과 MCP 간의 변환을 자동으로 처리합니다. 예를 들어, OpenAI와 Anthropic은 서로 다른 메시지 형식을 사용하지만, Robota는 이를 MCP로 표준화합니다.</p>
<pre><code class="language-typescript">// OpenAI 형식에서 MCP로 변환
function openaiToMCP(openaiResponse) {
  return {
    content: openaiResponse.choices[0].message.content,
    functionCall: openaiResponse.choices[0].message.function_call
      ? {
          name: openaiResponse.choices[0].message.function_call.name,
          arguments: JSON.parse(openaiResponse.choices[0].message.function_call.arguments)
        }
      : undefined,
    usage: {
      promptTokens: openaiResponse.usage.prompt_tokens,
      completionTokens: openaiResponse.usage.completion_tokens,
      totalTokens: openaiResponse.usage.total_tokens
    }
  };
}

// MCP에서 Anthropic 형식으로 변환
function mcpToAnthropic(mcpContext) {
  return {
    messages: mcpContext.messages.map(message =&gt; {
      if (message.role === &#39;user&#39;) {
        return { role: &#39;human&#39;, content: message.content };
      } else if (message.role === &#39;assistant&#39;) {
        return { role: &#39;assistant&#39;, content: message.content };
      }
      // 기타 변환 로직
    }),
    system: mcpContext.systemPrompt
  };
}
</code></pre>
<h2>커스텀 모델 통합하기</h2>
<p>새로운 AI 모델을 Robota에 통합하려면 해당 모델의 API와 MCP 간의 변환 로직을 구현해야 합니다:</p>
<pre><code class="language-typescript">import { BaseProvider, ModelContextProtocol } from &#39;robota&#39;;

class CustomModelProvider extends BaseProvider implements ModelContextProtocol {
  // MCP 컨텍스트를 모델 고유 형식으로 변환
  convertContextToModelFormat(context) {
    // 변환 로직 구현
    return customFormat;
  }

  // 모델 응답을 MCP 형식으로 변환
  convertModelResponseToMCP(modelResponse) {
    // 변환 로직 구현
    return mcpResponse;
  }
  
  // 기타 필요한 메서드 구현
}
</code></pre>
<h2>MCP의 이점</h2>
<ol>
<li><strong>제공업체 독립성</strong> - 애플리케이션 코드를 변경하지 않고 다른 AI 모델로 전환 가능</li>
<li><strong>표준화된 인터페이스</strong> - 일관된 방식으로 모든 AI 모델과 상호작용</li>
<li><strong>확장성</strong> - 새로운 모델과 제공업체를 쉽게 통합</li>
<li><strong>이식성</strong> - 다양한 환경에서 동일한 코드를 재사용</li>
</ol>

  </div>
</body>
</html>